{
  "version": 3,
  "sources": ["../../react-photo-view/src/hooks/useMethods.ts", "../../react-photo-view/src/hooks/useSetState.ts", "../../react-photo-view/src/photo-context.ts", "../../react-photo-view/src/variables.ts", "../../react-photo-view/src/utils/isTouchDevice.ts", "../../react-photo-view/src/utils/limitTarget.ts", "../../react-photo-view/src/hooks/useIsomorphicLayoutEffect.ts", "../../react-photo-view/src/hooks/useEventListener.ts", "../../react-photo-view/src/components/SlidePortal.tsx", "../../react-photo-view/src/components/CloseIcon.tsx", "../../react-photo-view/src/components/ArrowLeft.tsx", "../../react-photo-view/src/components/ArrowRight.tsx", "../../react-photo-view/src/components/PreventScroll.tsx", "../../react-photo-view/src/utils/getMultipleTouchPosition.ts", "../../react-photo-view/src/utils/edgeHandle.ts", "../../react-photo-view/src/utils/getPositionOnMoveOrScale.ts", "../../react-photo-view/src/utils/getRotateSize.ts", "../../react-photo-view/src/utils/getSuitableImageSize.ts", "../../react-photo-view/src/hooks/useDebounceCallback.ts", "../../react-photo-view/src/hooks/useScrollPosition.ts", "../../react-photo-view/src/hooks/useAnimationOrigin.tsx", "../../react-photo-view/src/hooks/useMountedRef.ts", "../../react-photo-view/src/components/Spinner.tsx", "../../react-photo-view/src/Photo.tsx", "../../react-photo-view/src/PhotoBox.tsx", "../../react-photo-view/src/hooks/useContinuousTap.ts", "../../react-photo-view/src/hooks/useAnimationPosition.ts", "../../react-photo-view/src/hooks/useTargetScale.ts", "../../react-photo-view/src/PhotoSlider.tsx", "../../react-photo-view/src/hooks/useAnimationVisible.tsx", "../../react-photo-view/src/hooks/useForkedVariable.ts", "../../react-photo-view/src/hooks/useAdjacentImages.ts", "../../react-photo-view/src/PhotoProvider.tsx", "../../react-photo-view/src/PhotoView.tsx", "../../react-photo-view/src/hooks/useInitial.ts"],
  "sourcesContent": ["import { useRef } from 'react';\n\n/**\n * Hook of persistent methods\n */\nexport default function useMethods<T extends Record<string, (...args: any[]) => any>>(fn: T) {\n  const { current } = useRef({\n    fn,\n    curr: undefined as T | undefined,\n  });\n  current.fn = fn;\n\n  if (!current.curr) {\n    const curr = Object.create(null);\n    Object.keys(fn).forEach((key) => {\n      curr[key] = (...args: unknown[]) => current.fn[key].call(current.fn, ...args);\n    });\n    current.curr = curr;\n  }\n\n  return current.curr as T;\n}\n", "import { useReducer } from 'react';\n\nexport default function useSetState<S extends Record<string, any>>(initialState: S) {\n  return useReducer(\n    (state: S, action: Partial<S> | ((state: S) => Partial<S>)) => ({\n      ...state,\n      ...(typeof action === 'function' ? action(state) : action),\n    }),\n    initialState,\n  );\n}\n", "import { createContext } from 'react';\nimport type { DataType } from './types';\n\nexport type UpdateItemType = (dataType: DataType) => void;\n\nexport interface PhotoContextType {\n  show: (key: number) => void;\n  update: UpdateItemType;\n  remove: (key: number) => void;\n  nextId: () => number;\n}\n\nexport default createContext<PhotoContextType>(undefined as unknown as PhotoContextType);\n", "/**\n * 最大触摸时间\n */\nexport const maxTouchTime = 200;\n\n/**\n * 默认动画速度\n */\nexport const defaultSpeed = 400;\n\n/**\n * 默认动画函数\n */\nexport const defaultEasing = 'cubic-bezier(0.25, 0.8, 0.25, 1)';\n\n/**\n * 最大滑动切换图片距离\n */\nexport const maxMoveOffset = 40;\n\n/**\n * 图片的间隔\n */\nexport const horizontalOffset = 20;\n\n/**\n * 最小初始响应距离\n */\nexport const minStartTouchOffset = 20;\n\n/**\n * 默认背景透明度\n */\nexport const defaultOpacity = 1;\n\n/**\n * 最小缩放度\n */\nexport const minScale = 1;\n\n/**\n * 最大缩放度（若图片足够大，则会超出）\n */\nexport const maxScale = 6;\n\n/**\n * 最小长图模式比例\n */\nexport const longModeRatio = 3;\n\n/**\n * 缩放弹性缓冲\n */\nexport const scaleBuffer = 0.2;\n\n/**\n * 最大等待动画时间\n */\nexport const maxWaitAnimationTime = 250;\n", "/**\n * 是否支持触摸设备\n */\nconst isTouchDevice = typeof window !== 'undefined' && 'ontouchstart' in window;\n\nexport default isTouchDevice;\n", "import { maxScale, minScale } from '../variables';\n\nexport const limitNumber = (value: number, min: number, max: number) => {\n  return Math.max(Math.min(value, max), min);\n};\n\n/**\n * 限制最大/最小缩放\n */\nexport const limitScale = (scale: number, max: number = 0, buffer: number = 0) => {\n  return limitNumber(scale, minScale * (1 - buffer), Math.max(maxScale, max) * (1 + buffer));\n};\n", "import { useEffect, useLayoutEffect } from 'react';\n\nconst isSSR = typeof window === 'undefined' || /ServerSideRendering/.test(navigator && navigator.userAgent);\n\nexport default isSSR ? useEffect : useLayoutEffect;\n", "import { useEffect, useRef } from 'react';\n\nexport default function useEventListener<K extends keyof WindowEventMap>(\n  type: K | undefined,\n  fn: (evt: WindowEventMap[K]) => void,\n  options?: AddEventListenerOptions,\n) {\n  const latest = useRef(fn);\n  latest.current = fn;\n\n  useEffect(() => {\n    function wrapper(evt: WindowEventMap[K]) {\n      latest.current(evt);\n    }\n    if (type) {\n      window.addEventListener(type, wrapper, options);\n    }\n    return () => {\n      if (type) {\n        window.removeEventListener(type, wrapper);\n      }\n    };\n  }, [type]);\n}\n", "import React from 'react';\nimport { createPortal } from 'react-dom';\nimport './SlidePortal.less';\n\nexport interface ISliderPortalProps extends React.HTMLAttributes<HTMLDivElement> {\n  container?: HTMLElement;\n}\n\nfunction SlidePortal({ container = document.body, ...rest }: ISliderPortalProps) {\n  return createPortal(<div {...rest} />, container);\n}\n\nexport default SlidePortal;\n", "import React from 'react';\n\nfunction CloseIcon(props: React.HTMLAttributes<SVGElement>) {\n  return (\n    <svg width=\"44\" height=\"44\" viewBox=\"0 0 768 768\" {...props}>\n      <path d=\"M607.5 205.5l-178.5 178.5 178.5 178.5-45 45-178.5-178.5-178.5 178.5-45-45 178.5-178.5-178.5-178.5 45-45 178.5 178.5 178.5-178.5z\" />\n    </svg>\n  );\n}\n\nexport default CloseIcon;\n", "import React from 'react';\n\nfunction ArrowLeft(props: React.HTMLAttributes<SVGElement>) {\n  return (\n    <svg width=\"44\" height=\"44\" viewBox=\"0 0 768 768\" {...props}>\n      <path d=\"M640.5 352.5v63h-390l178.5 180-45 45-256.5-256.5 256.5-256.5 45 45-178.5 180h390z\" />\n    </svg>\n  );\n}\n\nexport default ArrowLeft;\n", "import React from 'react';\n\nfunction ArrowRight(props: React.HTMLAttributes<SVGElement>) {\n  return (\n    <svg width=\"44\" height=\"44\" viewBox=\"0 0 768 768\" {...props}>\n      <path d=\"M384 127.5l256.5 256.5-256.5 256.5-45-45 178.5-180h-390v-63h390l-178.5-180z\" />\n    </svg>\n  );\n}\n\nexport default ArrowRight;\n", "import { useEffect } from 'react';\n\nexport default function PreventScroll() {\n  useEffect(() => {\n    const { style } = document.body;\n    const lastOverflow = style.overflow;\n    style.overflow = 'hidden';\n\n    return () => {\n      style.overflow = lastOverflow;\n    };\n  }, []);\n\n  return null;\n}\n", "import type React from 'react';\n\n/**\n * 从 Touch 事件中获取两个触控中心位置\n */\nexport default function getMultipleTouchPosition(\n  evt: TouchEvent | React.TouchEvent,\n): [clientX: number, clientY: number, touchLength: number] {\n  const { clientX, clientY } = evt.touches[0];\n  if (evt.touches.length >= 2) {\n    const { clientX: nextClientX, clientY: nextClientY } = evt.touches[1];\n    return [\n      (clientX + nextClientX) / 2,\n      (clientY + nextClientY) / 2,\n      Math.sqrt((nextClientX - clientX) ** 2 + (nextClientY - clientY) ** 2),\n    ];\n  }\n  return [clientX, clientY, 0];\n}\n", "import type { CloseEdgeType, ReachType, TouchStartType } from '../types';\n\n/**\n * 获取接触边缘类型\n */\nexport const getReachType = (\n  initialTouchState: TouchStartType,\n  horizontalCloseEdge: CloseEdgeType,\n  verticalCloseEdge: CloseEdgeType,\n  reachPosition: ReachType,\n): ReachType => {\n  if ((horizontalCloseEdge && initialTouchState === 1) || reachPosition === 'x') {\n    return 'x';\n  }\n  if ((verticalCloseEdge && initialTouchState > 1) || reachPosition === 'y') {\n    return 'y';\n  }\n  return undefined;\n};\n\n/**\n * 计算接触边缘位置\n * @param position - x/y\n * @param scale\n * @param size - width/height\n * @param innerSize - innerWidth/innerHeight\n * @return [CloseEdgeType, position]\n */\nexport const computePositionEdge = (position: number, scale: number, size: number, innerSize: number) => {\n  const currentWidth = size * scale;\n  // 图片超出的宽度\n  const outOffset = (currentWidth - innerSize) / 2;\n  let closedEdge: CloseEdgeType;\n\n  let current = position;\n  if (currentWidth <= innerSize) {\n    closedEdge = 1;\n    current = 0;\n  } else if (position > 0 && outOffset - position <= 0) {\n    closedEdge = 2;\n    current = outOffset;\n  } else if (position < 0 && outOffset + position <= 0) {\n    closedEdge = 3;\n    current = -outOffset;\n  }\n\n  return [closedEdge, current] as const;\n};\n", "import { longModeRatio } from '../variables';\nimport { computePositionEdge } from './edgeHandle';\n\n/**\n * 获取移动或缩放之后的中心点\n */\nexport default function getPositionOnMoveOrScale(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  scale: number,\n  toScale: number,\n  clientX: number = innerWidth / 2,\n  clientY: number = innerHeight / 2,\n  offsetX: number = 0,\n  offsetY: number = 0,\n) {\n  // 是否接触边缘\n  const [closedEdgeX] = computePositionEdge(x, toScale, width, innerWidth);\n  const [closedEdgeY] = computePositionEdge(y, toScale, height, innerHeight);\n\n  const centerClientX = innerWidth / 2;\n  const centerClientY = innerHeight / 2;\n\n  // 坐标偏移\n  const lastPositionX = centerClientX + x;\n  const lastPositionY = centerClientY + y;\n\n  // 偏移位置\n  const originX = clientX - (clientX - lastPositionX) * (toScale / scale) - centerClientX;\n  const originY = clientY - (clientY - lastPositionY) * (toScale / scale) - centerClientY;\n  // 长图模式无左右反馈\n  const longModeEdge = height / width >= longModeRatio && width * toScale === innerWidth;\n  // 超出边缘距离减半\n  return {\n    x: originX + (longModeEdge ? 0 : closedEdgeX ? offsetX / 2 : offsetX),\n    y: originY + (closedEdgeY ? offsetY / 2 : offsetY),\n    lastCX: clientX,\n    lastCY: clientY,\n  };\n}\n", "/**\n * 获取旋转后的宽高\n */\nexport default function getRotateSize(rotate: number, width: number, height: number) {\n  const isVertical = rotate % 180 !== 0;\n\n  // 若图片不是水平则调换属性\n  if (isVertical) {\n    return [height, width, isVertical] as const;\n  }\n\n  return [width, height, isVertical] as const;\n}\n", "import { longModeRatio } from '../variables';\nimport getRotateSize from './getRotateSize';\n\n/**\n * 获取图片合适的大小\n */\nexport default function getSuitableImageSize(naturalWidth: number, naturalHeight: number, rotate: number) {\n  const [currentWidth, currentHeight, isVertical] = getRotateSize(rotate, innerWidth, innerHeight);\n\n  let y = 0;\n  let width = currentWidth;\n  let height = currentHeight;\n\n  // 自适应宽高\n  const autoWidth = (naturalWidth / naturalHeight) * currentHeight;\n  const autoHeight = (naturalHeight / naturalWidth) * currentWidth;\n\n  if (naturalWidth < currentWidth && naturalHeight < currentHeight) {\n    width = naturalWidth;\n    height = naturalHeight;\n  } else if (naturalWidth < currentWidth && naturalHeight >= currentHeight) {\n    width = autoWidth;\n  } else if (naturalWidth >= currentWidth && naturalHeight < currentHeight) {\n    height = autoHeight;\n  } else if (naturalWidth / naturalHeight > currentWidth / currentHeight) {\n    height = autoHeight;\n  }\n  // 长图模式\n  else if (naturalHeight / naturalWidth >= longModeRatio && !isVertical) {\n    height = autoHeight;\n    y = (height - currentHeight) / 2;\n  } else {\n    width = autoWidth;\n  }\n  return {\n    width,\n    height,\n    x: 0,\n    y,\n    pause: true,\n  };\n}\n", "import { useCallback, useRef } from 'react';\n\ninterface DebounceCallback<CallbackArguments extends any[]> {\n  (...args: CallbackArguments): void;\n  cancel: () => void;\n}\n\nexport default function useDebounceCallback<CallbackArguments extends any[]>(\n  callback: (...args: CallbackArguments) => void,\n  {\n    leading = false,\n    maxWait,\n    wait = maxWait || 0,\n  }: {\n    leading?: boolean;\n    maxWait?: number;\n    wait?: number;\n  },\n): DebounceCallback<CallbackArguments> {\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n\n  const prev = useRef(0);\n  const trailingTimeout = useRef<ReturnType<typeof setTimeout>>();\n  const clearTrailing = () => trailingTimeout.current && clearTimeout(trailingTimeout.current);\n\n  const fn = useCallback(\n    (...args: CallbackArguments) => {\n      const now = Date.now();\n\n      function call() {\n        prev.current = now;\n        clearTrailing();\n        callbackRef.current.apply(null, args);\n      }\n      const last = prev.current;\n      const offset = now - last;\n      // leading\n      if (last === 0) {\n        if (leading) {\n          call();\n        }\n        prev.current = now;\n      }\n\n      // body\n      if (maxWait !== undefined) {\n        if (offset > maxWait) {\n          call();\n          return;\n        }\n      } else if (offset < wait) {\n        prev.current = now;\n      }\n\n      // trailing\n      clearTrailing();\n      trailingTimeout.current = setTimeout(() => {\n        call();\n        prev.current = 0;\n      }, wait);\n    },\n    [wait, maxWait, leading],\n  );\n  (fn as DebounceCallback<CallbackArguments>).cancel = clearTrailing;\n\n  return fn as DebounceCallback<CallbackArguments>;\n}\n", "import { computePositionEdge } from '../utils/edgeHandle';\nimport getPositionOnMoveOrScale from '../utils/getPositionOnMoveOrScale';\nimport getRotateSize from '../utils/getRotateSize';\nimport { defaultSpeed, maxTouchTime } from '../variables';\nimport useMethods from './useMethods';\n\n// 触边运动反馈\nconst rebound = (start: number, bound: number, callback: (spatial: number) => boolean) =>\n  easeOutMove(\n    start,\n    bound,\n    callback,\n    defaultSpeed / 4,\n    (t) => t,\n    () => easeOutMove(bound, start, callback),\n  );\n\n/**\n * 物理滚动到具体位置\n */\nexport default function useScrollPosition<C extends (spatial: number) => boolean>(\n  callbackX: C,\n  callbackY: C,\n  callbackS: C,\n) {\n  const callback = useMethods({\n    X: (spatial: number) => callbackX(spatial),\n    Y: (spatial: number) => callbackY(spatial),\n    S: (spatial: number) => callbackS(spatial),\n  });\n\n  return (\n    x: number,\n    y: number,\n    lastX: number,\n    lastY: number,\n    width: number,\n    height: number,\n    scale: number,\n    safeScale: number,\n    lastScale: number,\n    rotate: number,\n    touchedTime: number,\n  ) => {\n    const [currentWidth, currentHeight] = getRotateSize(rotate, width, height);\n    // 开始状态下边缘触发状态\n    const [beginEdgeX, beginX] = computePositionEdge(x, safeScale, currentWidth, innerWidth);\n    const [beginEdgeY, beginY] = computePositionEdge(y, safeScale, currentHeight, innerHeight);\n    const moveTime = Date.now() - touchedTime;\n\n    // 时间过长、超出安全范围的情况下不执行滚动逻辑，恢复安全范围\n    if (moveTime >= maxTouchTime || safeScale !== scale || Math.abs(lastScale - scale) > 1) {\n      // 计算中心缩放点\n      const { x: nextX, y: nextY } = getPositionOnMoveOrScale(x, y, width, height, scale, safeScale);\n      const targetX = beginEdgeX ? beginX : nextX !== x ? nextX : null;\n      const targetY = beginEdgeY ? beginY : nextY !== y ? nextY : null;\n\n      if (targetX !== null) {\n        easeOutMove(x, targetX, callback.X);\n      }\n      if (targetY !== null) {\n        easeOutMove(y, targetY, callback.Y);\n      }\n      if (safeScale !== scale) {\n        easeOutMove(scale, safeScale, callback.S);\n      }\n      return;\n    }\n\n    // 初始速度\n    const speedX = (x - lastX) / moveTime;\n    const speedY = (y - lastY) / moveTime;\n    const speedT = Math.sqrt(speedX ** 2 + speedY ** 2);\n    // 是否接触到边缘\n    let edgeX = false;\n    let edgeY = false;\n\n    scrollMove(speedT, (spatial) => {\n      const nextX = x + spatial * (speedX / speedT);\n      const nextY = y + spatial * (speedY / speedT);\n\n      const [isEdgeX, currentX] = computePositionEdge(nextX, scale, currentWidth, innerWidth);\n      const [isEdgeY, currentY] = computePositionEdge(nextY, scale, currentHeight, innerHeight);\n\n      if (isEdgeX && !edgeX) {\n        edgeX = true;\n        if (beginEdgeX) {\n          easeOutMove(nextX, currentX, callback.X);\n        } else {\n          rebound(currentX, nextX + (nextX - currentX), callback.X);\n        }\n      }\n\n      if (isEdgeY && !edgeY) {\n        edgeY = true;\n        if (beginEdgeY) {\n          easeOutMove(nextY, currentY, callback.Y);\n        } else {\n          rebound(currentY, nextY + (nextY - currentY), callback.Y);\n        }\n      }\n      // 同时接触边缘的情况下停止滚动\n      if (edgeX && edgeY) {\n        return false;\n      }\n\n      const resultX = edgeX || callback.X(currentX);\n      const resultY = edgeY || callback.Y(currentY);\n      return resultX && resultY;\n    });\n  };\n}\n\n// 加速度\nconst acceleration = -0.001;\n// 阻力\nconst resistance = 0.0002;\n\n/**\n * 通过速度滚动到停止\n */\nfunction scrollMove(initialSpeed: number, callback: (spatial: number) => boolean) {\n  let v = initialSpeed;\n  let s = 0;\n  let lastTime: number | undefined;\n  let frameId = 0;\n\n  const calcMove = (now: number) => {\n    if (!lastTime) {\n      lastTime = now;\n    }\n    const dt = now - lastTime;\n    const direction = Math.sign(initialSpeed);\n    const a = direction * acceleration;\n    const f = Math.sign(-v) * v ** 2 * resistance;\n    const ds = v * dt + ((a + f) * dt ** 2) / 2;\n    v += (a + f) * dt;\n\n    s += ds;\n    // move to s\n    lastTime = now;\n\n    if (direction * v <= 0) {\n      caf();\n      return;\n    }\n\n    if (callback(s)) {\n      raf();\n      return;\n    }\n    caf();\n  };\n  raf();\n\n  function raf() {\n    frameId = requestAnimationFrame(calcMove);\n  }\n  function caf() {\n    cancelAnimationFrame(frameId);\n  }\n}\n\n/**\n * 缓动函数\n */\nconst easeOutQuart = (x: number) => 1 - (1 - x) ** 4;\n\n/**\n * 缓动回调\n */\nfunction easeOutMove(\n  start: number,\n  end: number,\n  callback: (spatial: number) => boolean,\n  speed = defaultSpeed,\n  easing = easeOutQuart,\n  complete?: () => void,\n) {\n  const distance = end - start;\n  if (distance === 0) {\n    return;\n  }\n\n  const startTime = Date.now();\n  let frameId = 0;\n\n  const calcMove = () => {\n    const time = Math.min(1, (Date.now() - startTime) / speed);\n    const result = callback(start + easing(time) * distance);\n\n    if (result && time < 1) {\n      raf();\n      return;\n    }\n    cancelAnimationFrame(frameId);\n    if (time >= 1 && complete) {\n      complete();\n    }\n  };\n  raf();\n\n  function raf() {\n    frameId = requestAnimationFrame(calcMove);\n  }\n}\n", "import type { Dispatch, MutableRefObject, SetStateAction } from 'react';\nimport { useState, useEffect, useRef } from 'react';\nimport type { EasingMode, OriginRectType } from '../types';\nimport useMethods from './useMethods';\nimport { maxWaitAnimationTime } from '../variables';\n\nconst initialRect: OriginRectType = {\n  T: 0,\n  L: 0,\n  W: 0,\n  H: 0,\n  // 图像填充方式\n  FIT: undefined,\n};\n\nexport default function useAnimationOrigin(\n  visible: boolean | undefined,\n  originRef: MutableRefObject<HTMLElement | null> | undefined,\n  loaded: boolean,\n  speed: number,\n  updateEasing: (pause: boolean) => void,\n): [\n  // 动画状态\n  easingMode: EasingMode,\n  originRect: OriginRectType,\n] {\n  const [originRect, updateOriginRect] = useState(initialRect);\n  // 动画状态\n  const [easingMode, updateEasingMode] = useState<EasingMode>(0);\n  const initialTime = useRef<number>();\n\n  const fn = useMethods({\n    OK: () => visible && updateEasingMode(4),\n  });\n\n  useEffect(() => {\n    // 记录初始打开的时间\n    if (!initialTime.current) {\n      initialTime.current = Date.now();\n    }\n    if (!loaded) {\n      return;\n    }\n    handleUpdateOrigin(originRef, updateOriginRect);\n    // 打开动画处理\n    if (visible) {\n      // 小于最大允许动画时间，则执行缩放动画\n      if (Date.now() - initialTime.current < maxWaitAnimationTime) {\n        updateEasingMode(1);\n        // 延时执行动画，保持 transition 生效\n        requestAnimationFrame(() => {\n          updateEasingMode(2);\n          requestAnimationFrame(() => handleToShape(3));\n        });\n        setTimeout(fn.OK, speed);\n        return;\n      }\n      // 超出则不执行\n      updateEasingMode(4);\n      return;\n    }\n    // 关闭动画处理\n    handleToShape(5);\n  }, [visible, loaded]);\n\n  function handleToShape(currentShape: EasingMode) {\n    updateEasing(false);\n    updateEasingMode(currentShape);\n  }\n\n  return [easingMode, originRect];\n}\n\n/**\n * 更新缩略图位置信息\n */\nfunction handleUpdateOrigin(\n  originRef: MutableRefObject<HTMLElement | null> | undefined,\n  updateOriginRect: Dispatch<SetStateAction<typeof initialRect>>,\n) {\n  const element = originRef && originRef.current;\n\n  if (element && element.nodeType === 1) {\n    // 获取触发时节点位置\n    const { top, left, width, height } = element.getBoundingClientRect();\n    const isImage = element.tagName === 'IMG';\n    updateOriginRect({\n      T: top,\n      L: left,\n      W: width,\n      H: height,\n      FIT: isImage ? (getComputedStyle(element).objectFit as 'contain' | 'cover' | 'fill' | undefined) : undefined,\n    });\n  }\n}\n", "import { useEffect, useRef } from 'react';\n\nconst useMountedRef = () => {\n  const mountedRef = useRef(false);\n  useEffect(() => {\n    mountedRef.current = true;\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n  return mountedRef;\n};\n\nexport default useMountedRef;\n", "import React from 'react';\nimport './Spinner.less';\n\n// eslint-disable-next-line react/prop-types\nfunction Spinner({ className = '', ...props }: React.HTMLAttributes<HTMLElement>) {\n  return (\n    <div className={`PhotoView__Spinner ${className}`} {...props}>\n      <svg viewBox=\"0 0 32 32\" width=\"36\" height=\"36\" fill=\"white\">\n        <path opacity=\".25\" d=\"M16 0 A16 16 0 0 0 16 32 A16 16 0 0 0 16 0 M16 4 A12 12 0 0 1 16 28 A12 12 0 0 1 16 4\" />\n        <path d=\"M16 0 A16 16 0 0 1 32 16 L28 16 A12 12 0 0 0 16 4z\" />\n      </svg>\n    </div>\n  );\n}\n\nexport default Spinner;\n", "import React from 'react';\nimport Spinner from './components/Spinner';\nimport useMountedRef from './hooks/useMountedRef';\nimport type { BrokenElementParams } from './types';\nimport './Photo.less';\n\nexport interface IPhotoLoadedParams {\n  loaded?: boolean;\n  naturalWidth?: number;\n  naturalHeight?: number;\n  broken?: boolean;\n}\n\nexport interface IPhotoProps extends React.HTMLAttributes<HTMLElement> {\n  src: string;\n  loaded: boolean;\n  broken: boolean;\n  onPhotoLoad: (params: IPhotoLoadedParams) => void;\n  loadingElement?: JSX.Element;\n  brokenElement?: JSX.Element | ((photoProps: BrokenElementParams) => JSX.Element);\n}\n\nexport default function Photo({\n  src,\n  loaded,\n  broken,\n  className,\n  onPhotoLoad,\n  loadingElement,\n  brokenElement,\n  ...restProps\n}: IPhotoProps) {\n  const mountedRef = useMountedRef();\n\n  function handleImageLoaded(e: React.SyntheticEvent<HTMLImageElement>) {\n    const { naturalWidth, naturalHeight } = e.target as HTMLImageElement;\n    if (mountedRef.current) {\n      onPhotoLoad({\n        loaded: true,\n        naturalWidth,\n        naturalHeight,\n      });\n    }\n  }\n\n  function handleImageBroken() {\n    if (mountedRef.current) {\n      onPhotoLoad({\n        broken: true,\n      });\n    }\n  }\n\n  if (src && !broken) {\n    return (\n      <>\n        <img\n          className={`PhotoView__Photo${className ? ` ${className}` : ''}`}\n          src={src}\n          onLoad={handleImageLoaded}\n          onError={handleImageBroken}\n          draggable={false}\n          alt=\"\"\n          {...restProps}\n        />\n        {!loaded &&\n          (loadingElement ? (\n            <span className=\"PhotoView__icon\">{loadingElement}</span>\n          ) : (\n            <Spinner className=\"PhotoView__icon\" />\n          ))}\n      </>\n    );\n  }\n\n  if (brokenElement) {\n    return (\n      <span className=\"PhotoView__icon\">\n        {typeof brokenElement === 'function' ? brokenElement({ src }) : brokenElement}\n      </span>\n    );\n  }\n\n  return null;\n}\n", "import React, { useRef } from 'react';\nimport isTouchDevice from './utils/isTouchDevice';\nimport getMultipleTouchPosition from './utils/getMultipleTouchPosition';\nimport getPositionOnMoveOrScale from './utils/getPositionOnMoveOrScale';\nimport { getReachType, computePositionEdge } from './utils/edgeHandle';\nimport getRotateSize from './utils/getRotateSize';\nimport { limitScale } from './utils/limitTarget';\nimport getSuitableImageSize from './utils/getSuitableImageSize';\nimport useIsomorphicLayoutEffect from './hooks/useIsomorphicLayoutEffect';\nimport { minStartTouchOffset, scaleBuffer } from './variables';\nimport type {\n  DataType,\n  ReachMoveFunction,\n  ReachFunction,\n  PhotoTapFunction,\n  BrokenElementParams,\n  ExposedProperties,\n  ReachType,\n  TouchStartType,\n} from './types';\nimport useSetState from './hooks/useSetState';\nimport useMethods from './hooks/useMethods';\nimport useDebounceCallback from './hooks/useDebounceCallback';\nimport useEventListener from './hooks/useEventListener';\nimport useContinuousTap from './hooks/useContinuousTap';\nimport useScrollPosition from './hooks/useScrollPosition';\nimport useAnimationPosition from './hooks/useAnimationPosition';\nimport useMountedRef from './hooks/useMountedRef';\nimport type { IPhotoLoadedParams } from './Photo';\nimport Photo from './Photo';\nimport './PhotoBox.less';\n\nexport interface PhotoBoxProps {\n  // 图片信息\n  item: DataType;\n  // 是否可见\n  visible: boolean;\n  // 动画时间\n  speed: number;\n  // 动画函数\n  easing: string;\n  // 容器类名\n  wrapClassName?: string;\n  // 图片类名\n  className?: string;\n  // style\n  style?: object;\n  // 自定义 loading\n  loadingElement?: JSX.Element;\n  // 加载失败 Element\n  brokenElement?: JSX.Element | ((photoProps: BrokenElementParams) => JSX.Element);\n\n  // Photo 点击事件\n  onPhotoTap: PhotoTapFunction;\n  // Mask 点击事件\n  onMaskTap: PhotoTapFunction;\n  // 到达边缘滑动事件\n  onReachMove: ReachMoveFunction;\n  // 触摸解除事件\n  onReachUp: ReachFunction;\n  // Resize 事件\n  onPhotoResize: () => void;\n  // 向父组件导出属性\n  expose: (state: ExposedProperties) => void;\n  // 是否在当前操作中\n  isActive: boolean;\n}\n\nconst initialState = {\n  // 真实宽度\n  naturalWidth: undefined as number | undefined,\n  // 真实高度\n  naturalHeight: undefined as number | undefined,\n  // 宽度\n  width: undefined as number | undefined,\n  // 高度\n  height: undefined as number | undefined,\n  // 加载成功状态\n  loaded: undefined as boolean | undefined,\n  // 破碎状态\n  broken: false,\n\n  // 图片 X 偏移量\n  x: 0,\n  // 图片 y 偏移量\n  y: 0,\n  // 图片处于触摸的状态\n  touched: false,\n  // 背景处于触摸状态\n  maskTouched: false,\n  // 旋转状态\n  rotate: 0,\n  // 放大缩小\n  scale: 1,\n\n  // 触摸开始时 x 原始坐标\n  CX: 0,\n  // 触摸开始时 y 原始坐标\n  CY: 0,\n\n  // 触摸开始时图片 x 偏移量\n  lastX: 0,\n  // 触摸开始时图片 y 偏移量\n  lastY: 0,\n  // 上一个触摸状态 x 原始坐标\n  lastCX: 0,\n  // 上一个触摸状态 y 原始坐标\n  lastCY: 0,\n  // 上一个触摸状态的 scale\n  lastScale: 1,\n\n  // 触摸开始时时间\n  touchTime: 0,\n  // 多指触控间距\n  touchLength: 0,\n  // 是否暂停 transition\n  pause: true,\n  // 停止 Raf\n  stopRaf: true,\n  // 当前边缘触发状态\n  reach: undefined as ReachType,\n};\n\nexport default function PhotoBox({\n  item: { src, render, width: customWidth = 0, height: customHeight = 0, originRef },\n  visible,\n  speed,\n  easing,\n  wrapClassName,\n  className,\n  style,\n  loadingElement,\n  brokenElement,\n\n  onPhotoTap,\n  onMaskTap,\n  onReachMove,\n  onReachUp,\n  onPhotoResize,\n  isActive,\n  expose,\n}: PhotoBoxProps) {\n  const [state, updateState] = useSetState(initialState);\n  const initialTouchRef = useRef<TouchStartType>(0);\n  const mounted = useMountedRef();\n\n  const {\n    naturalWidth = customWidth,\n    naturalHeight = customHeight,\n    width = customWidth,\n    height = customHeight,\n    loaded = !src,\n    broken,\n    x,\n    y,\n    touched,\n    stopRaf,\n    maskTouched,\n    rotate,\n    scale,\n    CX,\n    CY,\n    lastX,\n    lastY,\n    lastCX,\n    lastCY,\n    lastScale,\n    touchTime,\n    touchLength,\n    pause,\n    reach,\n  } = state;\n\n  const fn = useMethods({\n    onScale: (current: number) => onScale(limitScale(current)),\n    onRotate(current: number) {\n      if (rotate !== current) {\n        expose({ rotate: current });\n        updateState({ rotate: current, ...getSuitableImageSize(naturalWidth, naturalHeight, current) });\n      }\n    },\n  });\n\n  // 默认为屏幕中心缩放\n  function onScale(current: number, clientX?: number, clientY?: number) {\n    if (scale !== current) {\n      expose({ scale: current });\n      updateState({\n        scale: current,\n        ...getPositionOnMoveOrScale(x, y, width, height, scale, current, clientX, clientY),\n        ...(current <= 1 && { x: 0, y: 0 }),\n      });\n    }\n  }\n\n  const handleMove = useDebounceCallback(\n    (nextClientX: number, nextClientY: number, currentTouchLength: number = 0) => {\n      if ((touched || maskTouched) && isActive) {\n        // 通过旋转调换宽高\n        const [currentWidth, currentHeight] = getRotateSize(rotate, width, height);\n        // 单指最小缩放下，以初始移动距离来判断意图\n        if (currentTouchLength === 0 && initialTouchRef.current === 0) {\n          const isStillX = Math.abs(nextClientX - CX) <= minStartTouchOffset;\n          const isStillY = Math.abs(nextClientY - CY) <= minStartTouchOffset;\n          // 初始移动距离不足\n          if (isStillX && isStillY) {\n            // 方向记录上次移动距离，以便平滑过渡\n            updateState({ lastCX: nextClientX, lastCY: nextClientY });\n            return;\n          }\n          // 设置响应状态\n          initialTouchRef.current = !isStillX ? 1 : nextClientY > CY ? 3 : 2;\n        }\n\n        const offsetX = nextClientX - lastCX;\n        const offsetY = nextClientY - lastCY;\n        // 边缘触发状态\n        let currentReach: ReachType;\n        if (currentTouchLength === 0) {\n          // 边缘超出状态\n          const [horizontalCloseEdge] = computePositionEdge(offsetX + lastX, scale, currentWidth, innerWidth);\n          const [verticalCloseEdge] = computePositionEdge(offsetY + lastY, scale, currentHeight, innerHeight);\n          // 边缘触发检测\n          currentReach = getReachType(initialTouchRef.current, horizontalCloseEdge, verticalCloseEdge, reach);\n\n          // 接触边缘\n          if (currentReach !== undefined) {\n            onReachMove(currentReach, nextClientX, nextClientY, scale);\n          }\n        }\n        // 横向边缘触发、背景触发禁用当前滑动\n        if (currentReach === 'x' || maskTouched) {\n          updateState({ reach: 'x' });\n          return;\n        }\n        // 目标倍数\n        const toScale = limitScale(\n          scale + ((currentTouchLength - touchLength) / 100 / 2) * scale,\n          naturalWidth / width,\n          scaleBuffer,\n        );\n        // 导出变量\n        expose({ scale: toScale });\n        updateState({\n          touchLength: currentTouchLength,\n          reach: currentReach,\n          scale: toScale,\n          ...getPositionOnMoveOrScale(x, y, width, height, scale, toScale, nextClientX, nextClientY, offsetX, offsetY),\n        });\n      }\n    },\n    {\n      maxWait: 8,\n    },\n  );\n\n  function updateRaf(position: { x?: number; y?: number }) {\n    if (stopRaf || touched) {\n      return false;\n    }\n    if (mounted.current) {\n      // 下拉关闭时可以有动画\n      updateState({ ...position, pause: visible });\n    }\n    return mounted.current;\n  }\n\n  const slideToPosition = useScrollPosition(\n    (nextX) => updateRaf({ x: nextX }),\n    (nextY) => updateRaf({ y: nextY }),\n    (nextScale) => {\n      if (mounted.current) {\n        expose({ scale: nextScale });\n        updateState({ scale: nextScale });\n      }\n      return !touched && mounted.current;\n    },\n  );\n\n  const handlePhotoTap = useContinuousTap(onPhotoTap, (currentClientX: number, currentClientY: number) => {\n    if (!reach) {\n      // 若图片足够大，则放大适应的倍数\n      const endScale = scale !== 1 ? 1 : Math.max(2, naturalWidth / width);\n      onScale(endScale, currentClientX, currentClientY);\n    }\n  });\n\n  function handleUp(nextClientX: number, nextClientY: number) {\n    // 重置响应状态\n    initialTouchRef.current = 0;\n    if ((touched || maskTouched) && isActive) {\n      updateState({\n        touched: false,\n        maskTouched: false,\n        pause: false,\n        stopRaf: false,\n        reach: undefined,\n      });\n      const safeScale = limitScale(scale, naturalWidth / width);\n      // Go\n      slideToPosition(x, y, lastX, lastY, width, height, scale, safeScale, lastScale, rotate, touchTime);\n\n      onReachUp(nextClientX, nextClientY);\n      // 触发 Tap 事件\n      if (CX === nextClientX && CY === nextClientY) {\n        if (touched) {\n          handlePhotoTap(nextClientX, nextClientY);\n          return;\n        }\n        if (maskTouched) {\n          onMaskTap(nextClientX, nextClientY);\n        }\n      }\n    }\n  }\n\n  useEventListener(isTouchDevice ? undefined : 'mousemove', (e) => {\n    e.preventDefault();\n    handleMove(e.clientX, e.clientY);\n  });\n  useEventListener(isTouchDevice ? undefined : 'mouseup', (e) => {\n    handleUp(e.clientX, e.clientY);\n  });\n  useEventListener(\n    isTouchDevice ? 'touchmove' : undefined,\n    (e) => {\n      e.preventDefault();\n      const position = getMultipleTouchPosition(e);\n      handleMove(...position);\n    },\n    { passive: false },\n  );\n  useEventListener(\n    isTouchDevice ? 'touchend' : undefined,\n    ({ changedTouches }) => {\n      const touch = changedTouches[0];\n      handleUp(touch.clientX, touch.clientY);\n    },\n    { passive: false },\n  );\n  useEventListener(\n    'resize',\n    useDebounceCallback(\n      () => {\n        if (loaded && !touched) {\n          updateState(getSuitableImageSize(naturalWidth, naturalHeight, rotate));\n          onPhotoResize();\n        }\n      },\n      { maxWait: 8 },\n    ),\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (isActive) {\n      expose({ scale, rotate, ...fn });\n    }\n  }, [isActive]);\n\n  function handlePhotoLoad(params: IPhotoLoadedParams) {\n    updateState({\n      ...params,\n      ...(params.loaded && getSuitableImageSize(params.naturalWidth || 0, params.naturalHeight || 0, rotate)),\n    });\n  }\n\n  function handleStart(currentClientX: number, currentClientY: number, currentTouchLength: number = 0) {\n    updateState({\n      touched: true,\n      CX: currentClientX,\n      CY: currentClientY,\n      lastCX: currentClientX,\n      lastCY: currentClientY,\n      lastX: x,\n      lastY: y,\n      lastScale: scale,\n      touchLength: currentTouchLength,\n      touchTime: Date.now(),\n    });\n  }\n\n  function handleWheel(e: React.WheelEvent) {\n    if (!reach) {\n      // 限制最大倍数和最小倍数\n      const toScale = limitScale(scale - e.deltaY / 100 / 2, naturalWidth / width);\n      updateState({ stopRaf: true });\n      onScale(toScale, e.clientX, e.clientY);\n    }\n  }\n\n  function handleMaskStart(e: { clientX: number; clientY: number }) {\n    updateState({\n      maskTouched: true,\n      CX: e.clientX,\n      CY: e.clientY,\n      lastX: x,\n      lastY: y,\n    });\n  }\n\n  function handleTouchStart(e: React.TouchEvent) {\n    e.stopPropagation();\n    handleStart(...getMultipleTouchPosition(e));\n  }\n\n  function handleMouseDown(e: React.MouseEvent) {\n    e.stopPropagation();\n    if (e.button === 0) {\n      handleStart(e.clientX, e.clientY, 0);\n    }\n  }\n\n  // 计算位置\n  const [translateX, translateY, currentWidth, currentHeight, currentScale, opacity, easingMode, FIT] =\n    useAnimationPosition(visible, originRef, loaded, x, y, width, height, scale, speed, (isPause: boolean) =>\n      updateState({ pause: isPause }),\n    );\n  // 图片 objectFit 渐变时间\n  const transitionLayoutTime = easingMode < 4 ? speed / 2 : easingMode > 4 ? speed : 0;\n  const transitionCSS = `transform ${speed}ms ${easing}`;\n\n  const attrs = {\n    className,\n    onMouseDown: isTouchDevice ? undefined : handleMouseDown,\n    onTouchStart: isTouchDevice ? handleTouchStart : undefined,\n    onWheel: handleWheel,\n    style: {\n      width: `${currentWidth}px`,\n      height: `${currentHeight}px`,\n      opacity,\n      objectFit: easingMode === 4 ? undefined : FIT,\n      transform: rotate ? `rotate(${rotate}deg)` : undefined,\n      transition:\n        // 初始状态无渐变\n        easingMode > 2\n          ? `${transitionCSS}, opacity ${speed}ms ease, height ${transitionLayoutTime}ms ${easing}`\n          : undefined,\n    },\n  };\n\n  return (\n    <div\n      className={`PhotoView__PhotoWrap${wrapClassName ? ` ${wrapClassName}` : ''}`}\n      style={style}\n      onMouseDown={!isTouchDevice && isActive ? handleMaskStart : undefined}\n      onTouchStart={isTouchDevice && isActive ? (e) => handleMaskStart(e.touches[0]) : undefined}\n    >\n      <div\n        className=\"PhotoView__PhotoBox\"\n        style={{\n          transform: `matrix(${currentScale}, 0, 0, ${currentScale}, ${translateX}, ${translateY})`,\n          transition: touched || pause ? undefined : transitionCSS,\n          willChange: isActive ? 'transform' : undefined,\n        }}\n      >\n        {src ? (\n          <Photo\n            src={src}\n            loaded={loaded}\n            broken={broken}\n            {...attrs}\n            onPhotoLoad={handlePhotoLoad}\n            loadingElement={loadingElement}\n            brokenElement={brokenElement}\n          />\n        ) : (\n          render && render({ attrs, scale: currentScale, rotate })\n        )}\n      </div>\n    </div>\n  );\n}\n", "import { useRef } from 'react';\nimport useDebounceCallback from './useDebounceCallback';\n\nexport type TapFuncType<T> = (...args: T[]) => void;\n\n/**\n * 单击和双击事件处理\n * @param singleTap - 单击事件\n * @param doubleTap - 双击事件\n * @return invokeTap\n */\nexport default function useContinuousTap<T>(singleTap: TapFuncType<T>, doubleTap: TapFuncType<T>): TapFuncType<T> {\n  // 当前连续点击次数\n  const continuousClick = useRef(0);\n\n  const debounceTap = useDebounceCallback(\n    (...args) => {\n      continuousClick.current = 0;\n      singleTap(...args);\n    },\n    {\n      wait: 300,\n    },\n  );\n\n  return function invokeTap(...args) {\n    continuousClick.current += 1;\n    debounceTap(...args);\n    // 双击\n    if (continuousClick.current >= 2) {\n      debounceTap.cancel();\n      continuousClick.current = 0;\n      doubleTap(...args);\n    }\n  };\n}\n", "import type { MutableRefObject } from 'react';\nimport useAnimationOrigin from './useAnimationOrigin';\nimport useTargetScale from './useTargetScale';\n\nexport default function useAnimationPosition(\n  visible: boolean | undefined,\n  originRef: MutableRefObject<HTMLElement | null> | undefined,\n  loaded: boolean,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  scale: number,\n  speed: number,\n  updateEasing: (pause: boolean) => void,\n) {\n  // 延迟更新 width/height\n  const [autoWidth, autoHeight, autoScale] = useTargetScale(width, height, scale, speed, updateEasing);\n  // 动画源处理\n  const [easingMode, originRect] = useAnimationOrigin(visible, originRef, loaded, speed, updateEasing);\n\n  // 计算动画位置\n  const { T, L, W, H, FIT } = originRect;\n  // 偏移量，x: 0, y: 0 居中为初始\n  const centerWidth = innerWidth / 2;\n  const centerHeight = innerHeight / 2;\n  const offsetX = centerWidth - (width * scale) / 2;\n  const offsetY = centerHeight - (height * scale) / 2;\n  // 缩略图状态\n  const miniMode = easingMode < 3 || easingMode > 4;\n  // 有缩略图时，则为缩略图的位置，否则居中\n  const translateX = miniMode ? (W ? L : centerWidth) : x + offsetX;\n  const translateY = miniMode ? (W ? T : centerHeight) : y + offsetY;\n\n  // 最小值缩放\n  const minScale = W / (width * scale) || 0.01;\n\n  // 适应 objectFit 保持缩略图宽高比\n  const currentHeight = miniMode && FIT ? autoWidth * (H / W) : autoHeight;\n  // 初始加载情况无缩放\n  const currentScale = easingMode === 0 ? autoScale : miniMode ? minScale : autoScale;\n  const opacity = miniMode ? (FIT ? 1 : 0) : 1;\n\n  return [translateX, translateY, autoWidth, currentHeight, currentScale, opacity, easingMode, FIT] as const;\n}\n", "import { useRef } from 'react';\nimport useSetState from './useSetState';\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect';\nimport useDebounceCallback from './useDebounceCallback';\n\n/**\n * 目标缩放延迟处理\n */\nexport default function useTargetScale(\n  realWidth: number,\n  realHeight: number,\n  realScale: number,\n  speed: number,\n  updateEasing: (pause: boolean) => void,\n) {\n  const execRef = useRef(false);\n\n  const [{ lead, scale }, updateState] = useSetState({ lead: true, scale: realScale });\n\n  const moveScale = useDebounceCallback(\n    async (current: number) => {\n      updateEasing(true);\n      updateState({ lead: false, scale: current });\n    },\n    { wait: speed },\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!execRef.current) {\n      execRef.current = true;\n      return;\n    }\n    updateEasing(false);\n    updateState({ lead: true });\n\n    moveScale(realScale);\n  }, [realScale]);\n\n  // 运动开始\n  if (lead) {\n    return [realWidth * scale, realHeight * scale, realScale / scale] as const;\n  }\n\n  // 运动结束\n  return [realWidth * realScale, realHeight * realScale, 1] as const;\n}\n", "import React, { useRef, useState } from 'react';\nimport type { DataType, PhotoProviderBase, OverlayRenderProps, ReachType } from './types';\nimport { defaultEasing, defaultSpeed, defaultOpacity, horizontalOffset, maxMoveOffset } from './variables';\nimport isTouchDevice from './utils/isTouchDevice';\nimport { limitNumber } from './utils/limitTarget';\nimport useIsomorphicLayoutEffect from './hooks/useIsomorphicLayoutEffect';\nimport useAdjacentImages from './hooks/useAdjacentImages';\nimport useSetState from './hooks/useSetState';\nimport useEventListener from './hooks/useEventListener';\nimport useAnimationVisible from './hooks/useAnimationVisible';\nimport useMethods from './hooks/useMethods';\nimport SlidePortal from './components/SlidePortal';\nimport CloseIcon from './components/CloseIcon';\nimport ArrowLeft from './components/ArrowLeft';\nimport ArrowRight from './components/ArrowRight';\nimport PreventScroll from './components/PreventScroll';\nimport PhotoBox from './PhotoBox';\nimport './PhotoSlider.less';\n\nexport interface IPhotoSliderProps extends PhotoProviderBase {\n  // 图片列表\n  images: DataType[];\n  // 图片当前索引\n  index?: number;\n  // 索引改变回调\n  onIndexChange?: (index: number) => void;\n  // 可见\n  visible: boolean;\n  // 关闭回调\n  onClose: (evt?: React.MouseEvent | React.TouchEvent) => void;\n  // 关闭动画结束后回调\n  afterClose?: () => void;\n\n  direction?: 'ltr' | 'rtl';\n}\n\ntype PhotoSliderState = {\n  // 偏移量\n  x: number;\n  // 图片处于触摸的状态\n  touched: boolean;\n  // 是否暂停 transition\n  pause: boolean;\n  // Reach 开始时 x 坐标\n  lastCX: number | undefined;\n  // Reach 开始时 y 坐标\n  lastCY: number | undefined;\n  // 背景透明度\n  bg: number | null | undefined;\n  // 上次关闭的背景透明度\n  lastBg: number | null | undefined;\n  // 是否显示 overlay\n  overlay: boolean;\n  // 是否为最小状态，可下拉关闭\n  minimal: boolean;\n  // 缩放\n  scale: number;\n  // 旋转\n  rotate: number;\n  // 缩放回调\n  onScale?: (scale: number) => void;\n  // 旋转回调\n  onRotate?: (rotate: number) => void;\n};\n\nconst initialState: PhotoSliderState = {\n  x: 0,\n  touched: false,\n  pause: false,\n  lastCX: undefined,\n  lastCY: undefined,\n  bg: undefined,\n  lastBg: undefined,\n  overlay: true,\n  minimal: true,\n  scale: 1,\n  rotate: 0,\n};\n\nexport default function PhotoSlider(props: IPhotoSliderProps) {\n  const {\n    loop = 3,\n    speed: speedFn,\n    easing: easingFn,\n    photoClosable,\n    maskClosable = true,\n    maskOpacity = defaultOpacity,\n    pullClosable = true,\n    bannerVisible = true,\n    overlayRender,\n    toolbarRender,\n    className,\n    maskClassName,\n    photoClassName,\n    photoWrapClassName,\n    loadingElement,\n    brokenElement,\n    images,\n    index: controlledIndex = 0,\n    onIndexChange: controlledIndexChange,\n    visible,\n    onClose,\n    afterClose,\n    portalContainer,\n  } = props;\n\n  const [state, updateState] = useSetState(initialState);\n  const [innerIndex, updateInnerIndex] = useState(0);\n\n  const {\n    x,\n    touched,\n    pause,\n\n    lastCX,\n    lastCY,\n\n    bg = maskOpacity,\n    lastBg,\n    overlay,\n    minimal,\n\n    scale,\n    rotate,\n    onScale,\n    onRotate,\n  } = state;\n\n  // 受控 index\n  const isControlled = props.hasOwnProperty('index');\n  const index = isControlled ? controlledIndex : innerIndex;\n  const onIndexChange = isControlled ? controlledIndexChange : updateInnerIndex;\n  // 内部虚拟 index\n  const virtualIndexRef = useRef(index);\n\n  // 当前图片\n  const imageLength = images.length;\n  const currentImage: DataType | undefined = images[index];\n\n  // 是否开启\n  // noinspection SuspiciousTypeOfGuard\n  const enableLoop = typeof loop === 'boolean' ? loop : imageLength > loop;\n\n  // 显示动画处理\n  const [realVisible, activeAnimation, onAnimationEnd] = useAnimationVisible(visible, afterClose);\n\n  useIsomorphicLayoutEffect(() => {\n    // 显示弹出层，修正正确的指向\n    if (realVisible) {\n      updateState({\n        pause: true,\n        x: index * -(innerWidth + horizontalOffset),\n      });\n      virtualIndexRef.current = index;\n      return;\n    }\n    // 关闭后清空状态\n    updateState(initialState);\n  }, [realVisible]);\n\n  const { close, changeIndex } = useMethods({\n    close(evt?: React.MouseEvent | React.TouchEvent) {\n      if (onRotate) {\n        onRotate(0);\n      }\n      updateState({\n        overlay: true,\n        // 记录当前关闭时的透明度\n        lastBg: bg,\n      });\n      onClose(evt);\n    },\n    changeIndex(nextIndex: number, isPause: boolean = false) {\n      // 当前索引\n      const currentIndex = enableLoop ? virtualIndexRef.current + (nextIndex - index) : nextIndex;\n      const max = imageLength - 1;\n      // 虚拟 index\n      // 非循环模式，限制区间\n      const limitIndex = limitNumber(currentIndex, 0, max);\n      const nextVirtualIndex = enableLoop ? currentIndex : limitIndex;\n      // 单个屏幕宽度\n      const singlePageWidth = innerWidth + horizontalOffset;\n\n      updateState({\n        touched: false,\n        lastCX: undefined,\n        lastCY: undefined,\n        x: -singlePageWidth * nextVirtualIndex,\n        pause: isPause,\n      });\n\n      virtualIndexRef.current = nextVirtualIndex;\n      // 更新真实的 index\n      const realLoopIndex = nextIndex < 0 ? max : nextIndex > max ? 0 : nextIndex;\n      if (onIndexChange) {\n        onIndexChange(enableLoop ? realLoopIndex : limitIndex);\n      }\n    },\n  });\n\n  useEventListener('keydown', (evt: KeyboardEvent) => {\n    if (visible) {\n      switch (evt.key) {\n        case 'ArrowLeft':\n          changeIndex(index - 1, true);\n          break;\n        case 'ArrowRight':\n          changeIndex(index + 1, true);\n          break;\n        case 'Escape':\n          close();\n          break;\n        default:\n      }\n    }\n  });\n\n  function handlePhotoTap(closeable: boolean | undefined) {\n    return closeable ? close() : updateState({ overlay: !overlay });\n  }\n\n  function handleResize() {\n    updateState({\n      x: -(innerWidth + horizontalOffset) * index,\n      lastCX: undefined,\n      lastCY: undefined,\n      pause: true,\n    });\n    virtualIndexRef.current = index;\n  }\n\n  function handleReachVerticalMove(clientY: number, nextScale?: number) {\n    if (lastCY === undefined) {\n      updateState({\n        touched: true,\n        lastCY: clientY,\n        bg,\n        minimal: true,\n      });\n      return;\n    }\n    const opacity =\n      maskOpacity === null ? null : limitNumber(maskOpacity, 0.01, maskOpacity - Math.abs(clientY - lastCY) / 100 / 4);\n\n    updateState({\n      touched: true,\n      lastCY,\n      bg: nextScale === 1 ? opacity : maskOpacity,\n      minimal: nextScale === 1,\n    });\n  }\n\n  function handleReachHorizontalMove(clientX: number) {\n    if (lastCX === undefined) {\n      updateState({\n        touched: true,\n        lastCX: clientX,\n        x,\n        pause: false,\n      });\n      return;\n    }\n    const originOffsetClientX = clientX - lastCX;\n    let offsetClientX = originOffsetClientX;\n\n    // 第一张和最后一张超出距离减半\n    if (\n      !enableLoop &&\n      ((index === 0 && originOffsetClientX > 0) || (index === imageLength - 1 && originOffsetClientX < 0))\n    ) {\n      offsetClientX = originOffsetClientX / 2;\n    }\n\n    updateState({\n      touched: true,\n      lastCX,\n      x: -(innerWidth + horizontalOffset) * virtualIndexRef.current + offsetClientX,\n      pause: false,\n    });\n  }\n\n  function handleReachMove(reachPosition: ReachType, clientX: number, clientY: number, nextScale?: number) {\n    if (reachPosition === 'x') {\n      handleReachHorizontalMove(clientX);\n    } else if (reachPosition === 'y') {\n      handleReachVerticalMove(clientY, nextScale);\n    }\n  }\n\n  function handleReachUp(clientX: number, clientY: number) {\n    const offsetClientX = clientX - (lastCX ?? clientX);\n    const offsetClientY = clientY - (lastCY ?? clientY);\n    let willClose = false;\n    // 下一张\n    if (offsetClientX < -maxMoveOffset) {\n      changeIndex(index + 1);\n      return;\n    }\n    // 上一张\n    if (offsetClientX > maxMoveOffset) {\n      changeIndex(index - 1);\n      return;\n    }\n    const singlePageWidth = innerWidth + horizontalOffset;\n    // 当前偏移\n    const currentTranslateX = -singlePageWidth * virtualIndexRef.current;\n\n    if (Math.abs(offsetClientY) > 100 && minimal && pullClosable) {\n      willClose = true;\n      close();\n    }\n    updateState({\n      touched: false,\n      x: currentTranslateX,\n      lastCX: undefined,\n      lastCY: undefined,\n      bg: maskOpacity,\n      overlay: willClose ? true : overlay,\n    });\n  }\n  // 截取相邻的图片\n  const adjacentImages = useAdjacentImages(images, index, enableLoop);\n\n  if (!realVisible) {\n    return null;\n  }\n\n  const currentOverlayVisible = overlay && !activeAnimation;\n  // 关闭过程中使用下拉保存的透明度\n  const currentOpacity = visible ? bg : lastBg;\n  // 覆盖物参数\n  const overlayParams: OverlayRenderProps | undefined = onScale &&\n    onRotate && {\n      images,\n      index,\n      visible,\n      onClose: close,\n      onIndexChange: changeIndex,\n      overlayVisible: currentOverlayVisible,\n      overlay: currentImage && currentImage.overlay,\n      scale,\n      rotate,\n      onScale,\n      onRotate,\n    };\n  // 动画时间\n  const currentSpeed = speedFn ? speedFn(activeAnimation) : defaultSpeed;\n  const currentEasing = easingFn ? easingFn(activeAnimation) : defaultEasing;\n  const slideSpeed = speedFn ? speedFn(3) : defaultSpeed + 200;\n  const slideEasing = easingFn ? easingFn(3) : defaultEasing;\n\n  return (\n    <SlidePortal\n      className={`PhotoView-Portal${!currentOverlayVisible ? ' PhotoView-Slider__clean' : ''}${\n        !visible ? ' PhotoView-Slider__willClose' : ''\n      }${className ? ` ${className}` : ''}`}\n      role=\"dialog\"\n      onClick={(e) => e.stopPropagation()}\n      container={portalContainer}\n    >\n      {visible && <PreventScroll />}\n      <div\n        className={`PhotoView-Slider__Backdrop${maskClassName ? ` ${maskClassName}` : ''}${\n          activeAnimation === 1\n            ? ' PhotoView-Slider__fadeIn'\n            : activeAnimation === 2\n              ? ' PhotoView-Slider__fadeOut'\n              : ''\n        }`}\n        style={{\n          background: currentOpacity ? `rgba(0, 0, 0, ${currentOpacity})` : undefined,\n          transitionTimingFunction: currentEasing,\n          transitionDuration: `${touched ? 0 : currentSpeed}ms`,\n          animationDuration: `${currentSpeed}ms`,\n        }}\n        onAnimationEnd={onAnimationEnd}\n      />\n      {bannerVisible && (\n        <div className=\"PhotoView-Slider__BannerWrap\">\n          <div className=\"PhotoView-Slider__Counter\">\n            {index + 1} / {imageLength}\n          </div>\n          <div className=\"PhotoView-Slider__BannerRight\">\n            {toolbarRender && overlayParams && toolbarRender(overlayParams)}\n            <CloseIcon className=\"PhotoView-Slider__toolbarIcon\" onClick={close} />\n          </div>\n        </div>\n      )}\n      {adjacentImages.map((item: DataType, currentIndex) => {\n        // 截取之前的索引位置\n        const nextIndex =\n          !enableLoop && index === 0 ? index + currentIndex : virtualIndexRef.current - 1 + currentIndex;\n\n        return (\n          <PhotoBox\n            key={enableLoop ? `${item.key}/${item.src}/${nextIndex}` : item.key}\n            item={item}\n            speed={currentSpeed}\n            easing={currentEasing}\n            visible={visible}\n            onReachMove={handleReachMove}\n            onReachUp={handleReachUp}\n            onPhotoTap={() => handlePhotoTap(photoClosable)}\n            onMaskTap={() => handlePhotoTap(maskClosable)}\n            wrapClassName={photoWrapClassName}\n            className={photoClassName}\n            style={{\n              left: `${(innerWidth + horizontalOffset) * nextIndex}px`,\n              transform: `translate3d(${x}px, 0px, 0)`,\n              transition: touched || pause ? undefined : `transform ${slideSpeed}ms ${slideEasing}`,\n            }}\n            loadingElement={loadingElement}\n            brokenElement={brokenElement}\n            onPhotoResize={handleResize}\n            isActive={virtualIndexRef.current === nextIndex}\n            expose={updateState}\n          />\n        );\n      })}\n      {!isTouchDevice && bannerVisible && (\n        <>\n          {(enableLoop || index !== 0) && (\n            <div className=\"PhotoView-Slider__ArrowLeft\" onClick={() => changeIndex(index - 1, true)}>\n              <ArrowLeft />\n            </div>\n          )}\n          {(enableLoop || index + 1 < imageLength) && (\n            <div className=\"PhotoView-Slider__ArrowRight\" onClick={() => changeIndex(index + 1, true)}>\n              <ArrowRight />\n            </div>\n          )}\n        </>\n      )}\n      {overlayRender && overlayParams && (\n        <div className=\"PhotoView-Slider__Overlay\">{overlayRender(overlayParams)}</div>\n      )}\n    </SlidePortal>\n  );\n}\n", "import { useReducer, useRef } from 'react';\nimport type { ActiveAnimationType } from '../types';\nimport useForkedVariable from './useForkedVariable';\n\n/**\n * 动画关闭处理真实关闭状态\n * 通过 onAnimationEnd 回调实现 leaveCallback\n */\nexport default function useAnimationVisible(\n  visible: boolean | undefined,\n  afterClose?: () => void,\n): [realVisible: boolean | undefined, activeAnimation: ActiveAnimationType, onAnimationEnd: () => void] {\n  const [, handleRender] = useReducer((c) => !c, false);\n\n  const activeAnimation = useRef<ActiveAnimationType>(0);\n\n  // 可见状态分支\n  const [realVisible, modifyRealVisible] = useForkedVariable(visible, (modify) => {\n    // 可见状态：设置进入动画\n    if (visible) {\n      modify(visible);\n      activeAnimation.current = 1;\n    } else {\n      activeAnimation.current = 2;\n    }\n  });\n\n  function onAnimationEnd() {\n    // 动画结束后触发渲染\n    handleRender();\n    // 结束动画：设置隐藏状态\n    if (activeAnimation.current === 2) {\n      modifyRealVisible(false);\n      // 触发隐藏回调\n      if (afterClose) {\n        afterClose();\n      }\n    }\n    // 重置状态\n    activeAnimation.current = 0;\n  }\n\n  return [\n    /**\n     * 真实可见状态\n     */\n    realVisible,\n    /**\n     * 正在进行的动画\n     */\n    activeAnimation.current,\n    /**\n     * 动画结束后回调\n     */\n    onAnimationEnd,\n  ];\n}\n", "import { useRef, useMemo } from 'react';\n\n/**\n * 逻辑分叉变量处理\n * 此 hook 不触发额外渲染\n */\nexport default function useForkedVariable<T>(initial: T, updater: (modify: (variable: T) => void) => void) {\n  // 初始分叉变量\n  const forkedRef = useRef(initial);\n\n  function modify(next: T) {\n    forkedRef.current = next;\n  }\n\n  useMemo(() => {\n    // 参数变化之后同步内部分叉变量\n    updater(modify);\n  }, [initial]);\n\n  return [forkedRef.current, modify] as const;\n}\n", "import { useMemo } from 'react';\nimport type { DataType } from '../types';\n\n/**\n * 截取相邻三张图片\n */\nexport default function useAdjacentImages(images: DataType[], index: number, loop: boolean) {\n  return useMemo(() => {\n    const imageLength = images.length;\n    if (loop) {\n      const connected = images.concat(images).concat(images);\n      return connected.slice(imageLength + index - 1, imageLength + index + 2);\n    }\n    return images.slice(Math.max(index - 1, 0), Math.min(index + 2, imageLength + 1));\n  }, [images, index, loop]);\n}\n", "import React, { useMemo, useRef } from 'react';\nimport type { DataType, PhotoProviderBase } from './types';\nimport useMethods from './hooks/useMethods';\nimport useSetState from './hooks/useSetState';\nimport PhotoContext from './photo-context';\nimport PhotoSlider from './PhotoSlider';\n\nexport interface PhotoProviderProps extends PhotoProviderBase {\n  children: React.ReactNode;\n  onIndexChange?: (index: number, state: PhotoProviderState) => void;\n  onVisibleChange?: (visible: boolean, index: number, state: PhotoProviderState) => void;\n}\n\ntype PhotoProviderState = {\n  images: DataType[];\n  visible: boolean;\n  index: number;\n};\n\nconst initialState: PhotoProviderState = {\n  images: [],\n  visible: false,\n  index: 0,\n};\n\nexport default function PhotoProvider({ children, onIndexChange, onVisibleChange, ...restProps }: PhotoProviderProps) {\n  const [state, updateState] = useSetState(initialState);\n  const uniqueIdRef = useRef(0);\n  const { images, visible, index } = state;\n\n  const methods = useMethods({\n    nextId() {\n      return (uniqueIdRef.current += 1);\n    },\n    update(imageItem: DataType) {\n      const currentIndex = images.findIndex((n) => n.key === imageItem.key);\n      if (currentIndex > -1) {\n        const nextImages = images.slice();\n        nextImages.splice(currentIndex, 1, imageItem);\n        updateState({\n          images: nextImages,\n        });\n        return;\n      }\n      updateState((prev) => ({\n        images: prev.images.concat(imageItem),\n      }));\n    },\n    remove(key: number) {\n      updateState((prev) => {\n        const nextImages = prev.images.filter((item) => item.key !== key);\n        const nextEndIndex = nextImages.length - 1;\n        return {\n          images: nextImages,\n          index: Math.min(nextEndIndex, index),\n        };\n      });\n    },\n    show(key: number) {\n      const currentIndex = images.findIndex((item) => item.key === key);\n      updateState({\n        visible: true,\n        index: currentIndex,\n      });\n      if (onVisibleChange) {\n        onVisibleChange(true, currentIndex, state);\n      }\n    },\n  });\n\n  const fn = useMethods({\n    close() {\n      updateState({\n        visible: false,\n      });\n\n      if (onVisibleChange) {\n        onVisibleChange(false, index, state);\n      }\n    },\n    changeIndex(nextIndex: number) {\n      updateState({\n        index: nextIndex,\n      });\n\n      if (onIndexChange) {\n        onIndexChange(nextIndex, state);\n      }\n    },\n  });\n\n  const value = useMemo(() => ({ ...state, ...methods }), [state, methods]);\n\n  return (\n    <PhotoContext.Provider value={value}>\n      {children}\n      <PhotoSlider\n        images={images}\n        visible={visible}\n        index={index}\n        onIndexChange={fn.changeIndex}\n        onClose={fn.close}\n        {...restProps}\n      />\n    </PhotoContext.Provider>\n  );\n}\n", "import type React from 'react';\nimport { useImperativeHandle, Children, cloneElement, useContext, useEffect, useMemo, useRef } from 'react';\nimport useInitial from './hooks/useInitial';\nimport useMethods from './hooks/useMethods';\nimport type { PhotoContextType } from './photo-context';\nimport PhotoContext from './photo-context';\nimport type { PhotoRenderParams } from './types';\n\nexport interface PhotoViewProps {\n  /**\n   * 图片地址\n   */\n  src?: string;\n  /**\n   * 自定义渲染，优先级比 src 低\n   */\n  render?: (props: PhotoRenderParams) => React.ReactNode;\n  /**\n   * 自定义覆盖节点\n   */\n  overlay?: React.ReactNode;\n  /**\n   * 自定义渲染节点宽度\n   */\n  width?: number;\n  /**\n   * 自定义渲染节点高度\n   */\n  height?: number;\n  /**\n   * 子节点，一般为缩略图\n   */\n  children?: React.ReactElement;\n  /**\n   * 触发的事件\n   */\n  triggers?: ('onClick' | 'onDoubleClick')[];\n}\n\nconst PhotoView: React.FC<PhotoViewProps> = ({\n  src,\n  render,\n  overlay,\n  width,\n  height,\n  triggers = ['onClick'],\n  children,\n}) => {\n  const photoContext = useContext<PhotoContextType>(PhotoContext);\n  const key = useInitial(() => photoContext.nextId());\n  const originRef = useRef<HTMLElement>(null);\n\n  useImperativeHandle((children as React.FunctionComponentElement<HTMLElement>)?.ref, () => originRef.current);\n\n  useEffect(() => {\n    return () => {\n      photoContext.remove(key);\n    };\n  }, []);\n\n  function invokeChildrenFn(eventName: string, e: React.SyntheticEvent) {\n    if (children) {\n      const eventFn = children.props[eventName];\n      if (eventFn) {\n        eventFn(e);\n      }\n    }\n  }\n\n  const fn = useMethods({\n    render(props: PhotoRenderParams) {\n      return render && render(props);\n    },\n    show(eventName: string, e: React.MouseEvent) {\n      photoContext.show(key);\n      invokeChildrenFn(eventName, e);\n    },\n  });\n\n  const eventListeners = useMemo(() => {\n    const listener = {};\n    triggers.forEach((eventName) => {\n      listener[eventName] = fn.show.bind(null, eventName);\n    });\n    return listener;\n  }, []);\n\n  useEffect(() => {\n    photoContext.update({\n      key,\n      src,\n      originRef,\n      render: fn.render,\n      overlay,\n      width,\n      height,\n    });\n  }, [src]);\n\n  if (children) {\n    return Children.only(cloneElement(children, { ...eventListeners, ref: originRef }));\n  }\n  return null;\n};\n\nexport default PhotoView;\n", "import { useRef } from 'react';\n\nexport default function useInitial<T extends (...args: any) => any>(callback: T) {\n  const { current } = useRef({ sign: false, fn: undefined as ReturnType<T> });\n  if (!current.sign) {\n    current.sign = true;\n    current.fn = callback();\n  }\n  return current.fn;\n}\n"],
  "mappings": "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",
  "names": ["useMethods", "fn", "current", "useRef", "curr", "undefined", "Object", "create", "keys", "forEach", "key", "_current$fn$key", "call", "apply", "concat", "slice", "arguments", "useSetState", "initialState", "useReducer", "state", "action", "_extends", "createContext", "defaultEasing", "horizontalOffset", "isTouchDevice", "window", "limitNumber", "value", "min", "max", "Math", "limitScale", "scale", "buffer", "test", "navigator", "userAgent", "useEffect", "useLayoutEffect", "useEventListener", "type", "options", "latest", "wrapper", "evt", "addEventListener", "removeEventListener", "_excluded", "SlidePortal", "_ref", "_ref$container", "container", "document", "body", "rest", "_objectWithoutPropertiesLoose", "createPortal", "React", "createElement", "CloseIcon", "props", "width", "height", "viewBox", "d", "ArrowLeft", "ArrowRight", "PreventScroll", "style", "lastOverflow", "overflow", "getMultipleTouchPosition", "_evt$touches$", "touches", "clientX", "clientY", "length", "_evt$touches$2", "nextClientX", "nextClientY", "sqrt", "pow", "computePositionEdge", "position", "size", "innerSize", "closedEdge", "currentWidth", "outOffset", "getPositionOnMoveOrScale", "x", "y", "toScale", "offsetX", "offsetY", "innerWidth", "innerHeight", "closedEdgeX", "_computePositionEdge2", "centerClientX", "centerClientY", "lastCX", "lastCY", "getRotateSize", "rotate", "isVertical", "getSuitableImageSize", "naturalWidth", "naturalHeight", "_getRotateSize", "currentHeight", "autoWidth", "autoHeight", "pause", "useDebounceCallback", "callback", "_ref$leading", "leading", "maxWait", "_ref$wait", "wait", "callbackRef", "prev", "trailingTimeout", "clearTrailing", "clearTimeout", "useCallback", "args", "now", "Date", "last", "offset", "setTimeout", "cancel", "rebound", "start", "bound", "easeOutMove", "defaultSpeed", "t", "easeOutQuart", "end", "speed", "easing", "complete", "distance", "startTime", "frameId", "calcMove", "time", "raf", "cancelAnimationFrame", "requestAnimationFrame", "initialRect", "T", "L", "W", "H", "FIT", "useMountedRef", "mountedRef", "Spinner", "_ref$className", "className", "fill", "opacity", "Photo", "src", "loaded", "broken", "onPhotoLoad", "loadingElement", "brokenElement", "restProps", "Fragment", "onLoad", "e", "_e$target", "target", "onError", "draggable", "alt", "touched", "maskTouched", "CX", "CY", "lastX", "lastY", "lastScale", "touchTime", "touchLength", "stopRaf", "reach", "PhotoBox", "_ref$item", "item", "render", "_ref$item$width", "customWidth", "_ref$item$height", "customHeight", "originRef", "visible", "wrapClassName", "onPhotoTap", "onMaskTap", "onReachMove", "onReachUp", "onPhotoResize", "isActive", "expose", "_useSetState", "updateState", "initialTouchRef", "mounted", "_state$naturalWidth", "_state$naturalHeight", "_state$width", "_state$height", "_state$loaded", "onScale", "onRotate", "handleMove", "currentTouchLength", "isStillX", "abs", "isStillY", "currentReach", "horizontalCloseEdge", "initialTouchState", "verticalCloseEdge", "reachPosition", "updateRaf", "singleTap", "doubleTap", "continuousClick", "debounceTap", "callbackX", "callbackY", "callbackS", "slideToPosition", "nextX", "nextY", "nextScale", "X", "spatial", "Y", "S", "safeScale", "touchedTime", "_computePositionEdge", "beginEdgeX", "beginX", "beginEdgeY", "beginY", "moveTime", "_getPositionOnMoveOrS", "targetX", "targetY", "speedX", "speedY", "speedT", "edgeX", "edgeY", "initialSpeed", "lastTime", "v", "s", "dt", "direction", "sign", "a", "f", "ds", "caf", "_computePositionEdge3", "isEdgeX", "currentX", "_computePositionEdge4", "isEdgeY", "currentY", "resultX", "resultY", "handlePhotoTap", "currentClientX", "currentClientY", "handleUp", "handleStart", "handleMaskStart", "preventDefault", "passive", "_ref2", "touch", "changedTouches", "useIsomorphicLayoutEffect", "_useAnimationPosition", "updateEasing", "_useTargetScale", "realWidth", "realHeight", "realScale", "execRef", "lead", "_useSetState$", "moveScale", "Promise", "resolve", "reject", "autoScale", "_useAnimationOrigin", "_useState", "useState", "originRect", "updateOriginRect", "_useState2", "easingMode", "updateEasingMode", "initialTime", "OK", "handleToShape", "currentShape", "element", "nodeType", "_element$getBoundingC", "getBoundingClientRect", "top", "left", "tagName", "getComputedStyle", "objectFit", "centerWidth", "centerHeight", "miniMode", "isPause", "currentScale", "transitionCSS", "attrs", "onMouseDown", "stopPropagation", "button", "onTouchStart", "onWheel", "deltaY", "transform", "transition", "translateX", "translateY", "willChange", "params", "bg", "lastBg", "overlay", "minimal", "PhotoSlider", "_props$loop", "loop", "speedFn", "easingFn", "photoClosable", "_props$maskClosable", "maskClosable", "_props$maskOpacity", "maskOpacity", "_props$pullClosable", "pullClosable", "_props$bannerVisible", "bannerVisible", "overlayRender", "toolbarRender", "maskClassName", "photoClassName", "photoWrapClassName", "images", "_props$index", "index", "controlledIndex", "controlledIndexChange", "onIndexChange", "onClose", "afterClose", "portalContainer", "innerIndex", "updateInnerIndex", "_state$bg", "isControlled", "hasOwnProperty", "virtualIndexRef", "imageLength", "currentImage", "enableLoop", "_useAnimationVisible", "handleRender", "c", "activeAnimation", "_useForkedVariable", "initial", "forkedRef", "modify", "next", "useMemo", "modifyRealVisible", "realVisible", "onAnimationEnd", "_useMethods", "close", "changeIndex", "nextIndex", "currentIndex", "limitIndex", "nextVirtualIndex", "singlePageWidth", "closeable", "handleResize", "handleReachMove", "originOffsetClientX", "offsetClientX", "handleReachUp", "offsetClientY", "willClose", "currentTranslateX", "adjacentImages", "currentOverlayVisible", "currentOpacity", "overlayParams", "overlayVisible", "currentSpeed", "currentEasing", "slideSpeed", "slideEasing", "role", "onClick", "background", "transitionTimingFunction", "transitionDuration", "animationDuration", "map", "PhotoProvider", "children", "onVisibleChange", "uniqueIdRef", "methods", "nextId", "update", "imageItem", "findIndex", "n", "nextImages", "splice", "remove", "filter", "show", "PhotoContext", "Provider", "PhotoView", "_ref$triggers", "triggers", "photoContext", "useContext", "useImperativeHandle", "ref", "eventName", "eventFn", "eventListeners", "listener", "bind", "Children", "only", "cloneElement"]
}
